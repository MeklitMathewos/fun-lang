## Features

* string split
* make run script
* write some simple programs
* ensure pure functions don't call non-pure ones
* add comments to source code
* parenthesis
* plus equals
* check for undefined and unused variables
* check for wrong number of arguments in function calls
* mandatory return statements in funs?
* regex
* multi-line allowance
* runtime type checking
* runtime diagnostics
* IO
    * read_file
    * write_file
* string
    * split
* back-in-time debugger
* write comments and readmes

## Done

* list - concat, pop (x)
* while loops (x)
* for loops for lists (x)
* if statements (x)
* print (x)
* have test runner execute the generated js (x)
* built-in functions and check for unknown functions (x)
* map/filter/reduce (x)
* more checks: can't do indexed assignment (x)
* add tokenizer and line info in checker and other diagnostics (x)
* test suite (x)
* index notation (x)
    * get
    * set
* type checking differentiating funs vs procs (x)
* funs (x)
* procs (x)
* numbers + simple arithmetic (x)
* strings + simple arithmetic (x)
* list (x)
* dictionaries (x)
* comments (x)

## Later

* type annotations
* source maps

## Built-in functions

* print
* map, filter, reduce
* split, starts_with, ends_with
* read_file, write_file
* http_request
* + operator for lists? Will have to compile to a function call
* compile to runtime function calls or erase them at generate time?
* runtime type checking would be one reason to have runtime functions (simpler output code)

## Checker Responsibilities

* both funs and procs:
    * correct number of call arguments to callables
    * referenced variables are defined
    * show warning for unused variables
* funs only:
    * no re-assignment of variables
    * no indexed assignments
    * no loops
    * no calls to non-funs
    * one return statement in each possible branch
* loose funs:
    * can only mutate values that were initialized within the function
    * no calls to non-funs
* type checking - (at a later future point)